package searches;

import entity.Unit;
import graph.GraphNode;
import javafx.util.Pair;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;

/**
 * @author : Evgeniy Kim
 * @version : 23/03/2016;
 *          <p>
 *          This is the class that performs a star searches.
 * @date : 07/02/16
 */
public class AStar {

    /**
     * Returns a path generated by the A* search, omits first node.
     *
     * @param unit the unit to search for
     * @param goal Goal Node
     * @return The route as a list of Graph Nodes
     */
    public static List<GraphNode> search(Unit unit, GraphNode goal) {

        Set<GraphNode> visited = new LinkedHashSet<>();
        Map<GraphNode, GraphNode> pred = new LinkedHashMap<>();
        // empty map, contains costs from origin along best known path
        Map<GraphNode, Integer> D = new LinkedHashMap<>();
        //records estimated total cost
        Map<GraphNode, Integer> f = new LinkedHashMap<>();
        ArrayList<Pair<GraphNode, GraphNode>> nodeAssociations = new ArrayList<>();

        Comparator<GraphNode> p = (o1, o2) -> {

            int value = f.get(o1);
            int value1 = f.get(o2);

            if (value == value1) {
                return 0;
            }

            if (value < value1) {
                return -1;
            }

            return 1;
        };

        PriorityQueue<GraphNode> pending = new PriorityQueue<>(5, p);
        GraphNode start = unit.getPosition();

        pending.add(unit.getPosition());
        D.put(start, 0);
        f.put(start, distance(start, goal));

        while (!pending.isEmpty()) {

            // dequeue with smallest f value;
            GraphNode n = pending.poll();

            if (n.equals(goal)) {

                visited.add(n);
                // make list, add goal first
                ArrayList<GraphNode> pathList = new ArrayList<>();

                if (start == goal) {

                    pathList.add(start);
                    unit.setVisited(new ArrayList<>(visited));
                    unit.setRoute(pathList);

                    return pathList;

                } else {
                    //not first, add goal
                    pathList.add(n);
                    //get the one before goal
                    n = pred.get(n);

                    //add rest
                    while (n != start) {

                        pathList.add(n);
                        n = pred.get(n);
                    }

                    //add first
                    Collections.reverse(pathList);
                    unit.setVisited(new ArrayList<>(visited));
                    unit.setRoute(pathList);
                    unit.setNodeAssociations(nodeAssociations);

                    return pathList;
                }

            }

            visited.add(n);

            for (GraphNode s : n.getSuccessors()) {

                if (!visited.contains(s) && (s.getBlockade() == null || s.getBlockade().isBreakable())) {

                    int cost = D.get(n) + distance(n, s);

                    if (!pending.contains(s) || cost < D.get(s)) {

                        pred.put(s, n);
                        D.put(s, cost);
                        f.put(s, D.get(s) + distance(s, goal));

                        if (!pending.contains(s)) {

                            pending.add(s);
                            nodeAssociations.add(new Pair<>(n, s));
                        }
                    }
                }
            }
        }

        return null;
    }

    /**
     * calculates the distance between 2 graph nodes
     *
     * @param a One of the node
     * @param b The other node
     * @return Euclidean distance between a and b
     */
    public static int distance(GraphNode a, GraphNode b) {

        //CHANGE DEPENDING ON IMPLEMENTATION
        int xDistance = Math.abs(a.getX() - b.getX());
        int yDistance = Math.abs(a.getY() - b.getY());

        return (int) Math.round(Math.sqrt((xDistance * xDistance) + (yDistance * yDistance)));
    }

}
